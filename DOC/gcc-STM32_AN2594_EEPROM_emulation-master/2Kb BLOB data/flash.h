#ifndef FLASH_H
#define FLASH_H

//-------------------------------------
// Макроопределения
//-------------------------------------


// Важное соглашение относительно структуры данных: 
//  Организация FLASH/SRAM памяти в STM32 микроконтроллерах является Little-Endian! Т.е. 
//  В МЛАДШИЕ адреса (Address)   записывается "наименее значимый" байт (МЛАДШИЙ: LSB).
//  В СТАРШИЕ адреса (Address+1) записывается "наиболее значимый" байт (СТАРШИЙ: MSB).
// Замечу, что при вычистке данных из FLASH/SRAM (ассемблерными командами передачи данных) в Регистр - порядок байтов/битов восстанавливается на естественный (слово 32-бит):
//  (старший бит)  31 30 29 28 27 26 25 24   23 22 21 20 19 18 17 16   15 14 13 12 11 10 9 8   7 6 5 4 3 2 1 0  (младший бит)
//  Операции побитового сдвига (над Регистрами) работают нормально. Например: побитовый сдвиг вправо >>1 уменьшает хранимое число в 2 раза...


// Размер ячейки FLASH памяти в STM32 микроконтроллерах = 2 байта (полуслово 16 бит):
//  Таким образом, если записывать целое число (uint16_t), то оно будет разбито на два байта и размещено в порядке "Little-Endian"...
//  А если вам нужно сохранить только целое число в 1 байт (uint8_t), то все-равно необходимо расходовать целую ячейку целиком (неизбежно еще один байт памяти будет израсходован впустую).
// А при записи во FLASH чисел большой разрядности (больше 16-битного полуслова) - 
//  необходимо итеративно разделить число на фрагменты по 2 байта (точнее, по 16-бит в естественном порядке, поскольку число еще обрабатывается в Регистре), начиная с младших битов (побитовым сдвигом вправо), 
//  и несколько раз последовательно вызвать стандартный метод "запись полуслова": FLASH_Program_HalfWord(Address+=2, (uint16_t)(Data>>=16));


// Важное соглашение относительно порядка записи: 
//  Технология любой FLASH памяти такова, что данные в ячейке перезаписываются операцией "Побитовый AND".
//  Поэтому, в общем случае, данные в ячейку можно записать только один раз. Т.е. данные в страницу FLASH памяти только ДОПИСЫВАЮТСЯ, но никак не перезаписываются!
//  А потом, по заполнению, всю страницу памяти нужно заново стирать ЦЕЛИКОМ (все данные теряются), и записывать заново...
// Однако, есть хитрожопый трюк: 
//  Если рассматривать ячейку памяти не как "число кодированное в двоичном коде", а как "число кодированное в ПОЗИЦИОННОМ коде" - то ячейку можно ПЕРЕЗАПИСЫВАТЬ поБИТово. 
//  Но Биты в ячейке можно переводить только из 1 в 0...
//  Например, технически можно перезаписывать данные в следующем порядке (но не в обратном!):  0b1111 1111 -> ... -> 0b00001111 -> 0b00000111 -> 0b00000011 -> 0b00000001 -> 0b00000000  (и на этом все, далее уже никаких изменений данных, в этой ячейке, больше сделать нельзя - нужно стирать страницу)
//  Эта хитрость может использоваться для перезаписи "статус-кода" маркирующего страницу памяти, что используется в некоторых библиотеках. (Где, "статус-код" обычно располагается по известному адресу, например, в самой первой ячейке страницы.)
// Внимание: оказалось, что нельзя так просто стирать по одному биту в любой ячейке и в любом порядке (возникает ошибка во FLASH_WaitForLastOperation)! И не все последовательности перезаписи работают! Подробнее: см. экспериментальный метод FLASH_CheckRewriteSequence()...


// Макрос проверяет: принадлежит ли указанный ADDRESS диапазону FLASH-памяти (включая, Bank1 или Bank2)
#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF))



//-------------------------------------
// Методы API: обёртки стандартного HAL
//-------------------------------------


// Стереть несколько страниц FLASH подряд (адрес должен указывать на начало первой страницы)
HAL_StatusTypeDef FLASH_ErasePages(uint32_t Page_Address, uint32_t NbPages);

// Записать данные во FLASH
HAL_StatusTypeDef FLASH_Program_UINT8 (uint32_t Address, uint8_t  Data);
HAL_StatusTypeDef FLASH_Program_UINT16(uint32_t Address, uint16_t Data);
HAL_StatusTypeDef FLASH_Program_UINT32(uint32_t Address, uint32_t Data);
HAL_StatusTypeDef FLASH_Program_UINT64(uint32_t Address, uint64_t Data);

// Прочитать данные из FLASH (вспомогательные Getters для чисел стандартных целых типов)
uint8_t  FLASH_Read_UINT8 (uint32_t Address);
uint16_t FLASH_Read_UINT16(uint32_t Address);
uint32_t FLASH_Read_UINT32(uint32_t Address);
uint64_t FLASH_Read_UINT64(uint32_t Address);



//-------------------------------------
// Методы API из "AN2594: EEPROM emulation in STM32F10x microcontrollers"
//-------------------------------------


// Стереть одну страницу FLASH (адрес должен указывать на начало страницы)
HAL_StatusTypeDef AN2594_ErasePage(uint32_t Page_Address);

// Записать данные во FLASH
HAL_StatusTypeDef AN2594_ProgramHalfWord(uint32_t Address, uint16_t Data);

// Эксперименты с FLASH памятью: поиск рабочей последовательности деградации статус-кодов...
HAL_StatusTypeDef FLASH_CheckRewriteSequence(void);



#endif  // FLASH_H
